# Final report—Pokemon Card Trading System   

## **Video Link**  
## 1. Please list out changes in directions of your project if the final project is different from your original proposal (based on your stage 1 proposal submission).    
 (1) We planned to show the seller personal information when a buyer is browsing the on-sale card in our original proposal, but we just showed the card’s information in our implementation, and this change makes the user unable to trade with another designated user, and we will improve it in the future work.    
 (2) In our original proposal, we mentioned creating a function to guess users’ preferences would be cool, and in the implementation, we didn’t achieve this function. But we did finish the part of analyzing the blind-box selling and the box- probability checking function, we can clearly know the selling trend and whether the probability is proper through these, and we think these two functions are very cool as well.    

## 2. Discuss what you think your application achieved or failed to achieve regarding its usefulness.    
We did a good job about the core goals of our project, which is the randomness of opening blind boxes, the opened card can be traded through user and user, and we also finish the admin functions like the total selling analysis or the possibility checking. Also, we have set several filters to help users search easier. But if we evaluate this project as a real useful commercial system, it still has a lot to achieve. Like we have not implemented the users’ balance, which is one of the most important parts,  there are still some bugs that need to be fixed and our front-end can be improved to be more beautiful to attract the customers.        

## 3. Discuss if you changed the schema or source of the data for your application   
We did not change our schema or source during developing our project. But if we change it, we will revise the structure of our database. Our present database structure is very concise, but it means if we want to change the data it will affect many other attributes. For example, our Owned_card table has too many attributes. It can show which users the card belongs to, what status it is, how much it is, so if we change the user attribute of it, which means this card is traded from one user to another, but we will never know who had held this card before(we just know who held the card now), so this will bring a kind of data missing, so to advance our database, we should create more tables(but not redundant) and make it more detailed. We didn't change the data source for the Pokemon cards, but we said in the proposal that we would randomly generate user data, and we found that we didn't need that much user data, so we created some manually.       

## 4. Discuss what you change to your ER diagram and/or your table implementations. What are some differences between the original design and the final design? Why? What do you think is a more suitable design? 
We did not have a major change to our ER diagram and table implementations since the initial design of our project is deliberate. But have some minor modifications, such as adding attributes of description and images to the blindbox entity. We think our design now is suitable.

## 5. Discuss what functionalities you added or removed. Why?
Compare to the proposal, we basically did not change the basic functions, we remove the sorting function and replace it with filters, because we want keep the new cards at the top, and there are not many properties worth sorting. In addition to the functionalities we demonstrated last time, we added functionalities that can display users’ periodical trend of price changing of Pokemon cards. This is a significant function in our application, especially the part of resaling, because the information of the price change of a card is important for users to decide whether or sell or purchase certain cards. When users want to sell cards, they always care about if the potential trading is profitable, which depends on how the selling price is different from their purchasing price, thus, they can make use of this functionality to infer the future price change of the card to make the decision. The case is the same for the users who intend to purchase cards, which means they can infer the future price trend according to the functionality and make decision.     

## 6. Explain how you think your advanced database programs complement your application.   
Since our application is mainly for selling blindbox of Pokemon cards, one target consideration of advanced data programs development is to boost the user stickiness. Therefore, other than that users can sale their own cards and purchase other users’ cards on the platform to increase the possibility of users to have their wanted cards, we designed our advanced database program to automatically give a discount and offer users free cards randomly according to their payment amount, or we offer use cards if the user reach the payment amount and number we set, which, on one hand, makes users feel rewarded, therefore, more willing to continue to use our application, on the other hand, encourages users to purchase more blindbox. Hence, according to these points, the advanced database programs complement our application perfectly.     

## 7. Each team member should describe one technical challenge that the team encountered.  This should be sufficiently detailed such that another future team could use this as helpful advice if they were to start a similar project or where to maintain your project. 

**Yanying Yu**:    
The hardest part for me was to use ajax and send-accept JSON files. Because we had lots of dynamic events on the front-end, like each row shown in the front-end has a button leading to a related pop-up window, then in the window, we would show a line chart visualization.  it is hard for me to send the information from the back-end to the front-end and show the information on the pop-up window. So my solution is to use id in a flexible way, and although the PyCharm will highlight the code, it is not an error at all.      
**Billhonam Wong**:    
One of the challenges I had was how to connect the project to Mysql on GCP so that all team members could work together on the same database from the beginning, although there is a video on PrairieLearn teaching how to deploy using Google Cloud Proxy , but there is an easier way is to directly add each person's ip address in the connection in SQL on GCP, and then change the ip address, username and password in the project from localhost to the instance on GCP. I think this may help future teams.         

**Jiajun Wang**:   
For me, the most difficult part of this project is using Django structure to execute SQL queries, actually it can create one object censor and using censor.connecting to connect with the database, and then writing the SQL queries below.(ALL in the veiws.py) And another challenge is the trigger part, first I write the trigger query inside one function, and  everytime this function is called, the query will be executed one time, and it will be an error ’the trigger is already exist’, and then I find write it separately will be fine, and it only will be executed one time.    

**Nengyu Wang**:    
The implementation of card and box filters is challenging for me, not only for the reason of using Django framework to perform queries in SQL database, which required me to learn Django from zero, but also because I had to consider all situations how users will use the filters, in normal or unnormal ways. For example, I have to guarantee the filters can work well when users select conflicting conditions. Another challenge is stored procedure. Coming up with reasonable idea that uses two advanced queries takes me a lot of time. Besides, calculating the total payment amount in a certain period of time is also technically difficult.     

## 8. Are there other things that changed comparing the final application with the original proposal?
In terms of creative functions, we plan to implement a recommendation function in the proposal to make recommendations by storing user search records. Because this requires modifying the data table, we dropped this function due to time factors. For Box order history and Resale history, our current setting is that users can see all the history. The proposal seems to say that they can see their own history, but it is very simple to switch this. Compared with UI mockup, our implementation is basically the same, but there are still some differences in arrangement and style, and some small features do not appear in the actual project

## 9. Describe future work that you think, other than the interface, that the application can improve on
First, we thought we needed to add pagination. The lack of pagination can make the browsing experience worse as there are more and more cards. Secondly, the shopping cart is also a convenient function, and now our application can only support one product purchase at a time. In addition, the sorting function of Box and Cards, the filtering function of order history, and the recommendation function can also be considered. In the end, I think it's necessary to deploy it on GCP or some other server so that it can run independently.

## 10. Describe the final division of labor and how well you managed teamwork. 
We had about 10 in person meetings outside of the course, and basically every time we worked together for a whole day, so a lot of work was done by helping each other and doing it together. Specifically, in the early stages, Yanying and Bill were responsible for the design of the database, drawing diagrams, crawling data, and deploying the project and database. Nengyu and Jiajun were responsible for designing part of the data and entering the data. Bill and jiajun design and complete two advanced queries. In the midterm stage, Yanying developed all the front-end, the other three developed the back-end, Jiajun developed the Blindbox part, Bill developed the Resale part, and Nengyu developed the feature functions. In the final stage, Jiajun designed and implemented the trigger, Nengyu designed and implemented the Procedure, Bill completed the modifications and backend code, and Yanying developed the creative components. Yanying is the main speaker, and the other three mainly write reports.

